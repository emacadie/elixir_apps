To work w/Elixir on my machine:
ELIXIR_DIR=/home/ericm/tmp/elixir/elixir/bin
PATH=$ELIXIR_DIR:$PATH

To do it interactively in emacs:
M-x shell
cd /home/ericm/tmp/elixir/elixir/bin
PATH=$PATH:`pwd`

In interactive shell, to do previous commands, C-<up-arrow>

https://elixir-lang.org/docs.html

iex brings up interactive mode
command line has a counter

Numbers:
"5 + 5" gives "10"
"5 * 5" gives "25"
"i 5 * 5" gives answer and type (integer)
You could also do:
b = 5 * 5
i b
Tells you it's an integer.
I think "i" means "inspect"
"i 10/5" gives a float
"div(10, 5)" returns an integer

we can enter hex:
0xff
For binary:
0b1111
exponential syntax:
2.0e2 is 200.0
2.0e-3 is 0.002
You can put underscores in numbers:
one_billion = 1_000_000_000
It still displays in the prompt as "1000000000"
So I guess Elixir people like snake case
No max number for integer (limit is 2.1 billion in C#, or 2_100_000_000)
1 quintillion (1 w/18 zeroes)
Exponents:
https://stackoverflow.com/questions/32024156/how-do-i-raise-a-number-to-a-power-in-elixir
Perhaps use Elixir for math?
(although I have heard that Erlang VM is not good for that)


Atoms:
https://hexdocs.pm/elixir/Atom.html#content
A constant where its name is also its value
A colon and its name
:firstname
:"this is also an atom"
IO.puts to print it
gives atom :ok
to let us know it was okay
:error is another common one
They come in return values, which are tuples, like in Go
A function could return:
{:ok, content}
or 
{:error, reason}
They are memory efficient.
I think Clojure keywords can hold a value
In Elixir, they are mapped to integers
Boolean atoms are :true and :false
You can eliminate colon for those
:nil can also be used without the leading colon

Strings:
https://hexdocs.pm/elixir/String.html#content
UTF8
combine strings with/ operator "<>"
hello = "Hello, "
name = "Big Jim"
hello <> name
That will take a lot of getting used to.

What about put a value in middle of string:
String interpolation
handle = "some_handle"
"My twitter handle is @#{handle}. Feel free to send me a message."

one = 1
"Test: #{one}"
prints : "Test: 1"
If you do:
numbers = [1, 2, 3]
"Test #{numbers}"
You get:
<<84, 101, 115, 116, 32, 1, 2, 3>>
This is the Ascii codes for letters in "Test"
Why does it do that for list? He doesn't really say
Add a null byte to the end:
iex(25)> "one" <> <<0>>
<<111, 110, 101, 0>>
So I guess "<<" and ">>" are used to working with bytes

Tuples:
https://hexdocs.pm/elixir/Tuple.html#content
An ordered collection, up to about 4 elements
Some functions return tuples, like Go
book = {"Programming Elixir", "Dave Thomas", 25.00}
You can have multiple data types: numbers, strings, atoms
Use "elem" function to get items, 0-based
To get price from book tuple, do:
elem( book, 2 )
to update, use put_elem:
put_elem( book, 2, 48.00)
It creates a new tuple (so it's immutable)
Of course, we could do: 
book = put_elem( book, 2, 48.00)
"=" is matching, not assigning
Elixer matches a w/ 1 + 1 if we do:
a = 1 + 1
We could match w/tuples:
{title1, author1, price1} = book
Elixir "matches" everything on left to what is on right
(This sounds like assignment, but I will go with it for now)

What if we just want some of the elements?
Use underscore
{title2, author2, _} = book
Sort of like Go

Lists:
options[:notify_user]
Better data structures if more elements
Do not need to be same type
first_list = [1, 2, 3]
second_list = [:ok, 1, "test", first_list]
Lists have a head and a tail
hd(first_list)
tl(first_list)
Sort of like "car" and "cdr", but with better names
You can also use the pipe operator to create lists
third_list = [ 1 | [2, 3] ]
That gives "[1, 2, 3]"
fourth_list = [1 | [2 | [3 | []]]]
You need that empty list in there.
So you are pre-pending to lists
Lists are singly-linked
Getting 1-millionth item from list can be slow
Faster to put item on head of list than tail
Is Lisp like this? Perhaps Lisp got something wrong.
But Clojure has vectors.
Untyped arrays are slow in Racket. They recommend using Typed Racket.
Racket vectors are fixed-length
Pattern matching with lists:
[a, b, c] = [1, 2, 3]
Now a is 1, b is 2, c is 3
[head | tail ] = [1, 2, 3]
Now "head" is 1, and "tail" is [2, 3]
Special type of list: keyword list
options = [{:is_active, false}, {:notify_user, true}, {:create_if_not_exists, true}]
(this looks like a map to me)
Then you can get a value like this:
options[:notify_user]

Immutability
Once a list is created, it will not change
To add to a list, you 
languages = ["Elixir", "C#", "JavaScript"]
List.insert_at(languages, 0, "C++")
That returns: ["C++", "Elixir", "C#", "JavaScript"]
But languages still has: ["Elixir", "C#", "JavaScript"]
It takes the head, and then makes a pointer to the original list
Benefits: 
1. Good for concurrency
2. Efficient memory use

If you do:
counter = 1
then 
counter = counter + 1
You are actually "re-binding" counter to new data.
Honestly, that sounds mutable to me.

Maps
https://hexdocs.pm/elixir/Map.html#content
Key/value pairs
The key does not have to be an atom, only one instance of each key
In a keyword list, apparently you can use the same key multiple times
Maps can have any type
first_map = %{"one" => :one, 3 => "three"}
my_map = %{1 => {"Nate", "Taylor", "his.email@gmail.com"}, 2 => {"Charles", "Otherdude", "other.dude@gmail.com"}}

A tuple can be a key
other_map = %{:names => ["Nate Tyler", "Charles Smidgen"], "gender" => "male"}
another_map = %{{:ok, 1} => true, {:ok, 2} => false}
You can get values like this:
other_map["gender"]
other_map[:names]
If the key is an atom, you can call it directly:
other_map.names
Pattern matching:
%{:names => names_list} = other_map
Then names_list gives:
["Nate Tyler", "Charles Smidgen"]
It matches on the key and gets the value



